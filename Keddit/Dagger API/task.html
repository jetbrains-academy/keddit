<html>
<p><b>Dagger API</b></p>
<p>As you may know, Dagger has 4 main annotations to provide dependency injection (there are others but they are not covered here)</p>
<ul>
    <li><code>@Modules</code> + <code>@Provides</code>: provides dependencies.</li>
    <li><code>@Injects</code>: request dependencies.</li>
    <li><code>@Component</code>: bridge between modules and injections.</li>
</ul>
<p>Thanks to default constructors in Kotlin, some dependencies from the constructor were already provided, so you don’t have to change so much your code in the Keddit App in order to provide these dependencies.</p>
<p><b>@Modules</b></p>
<p>3 modules were created:</p>
<ul>
    <li><code>AppModule</code>: provides the <code>Context</code> and the instance to Keddit application.</li>
    <li><code>NetworkModule</code>: provides an instance of Retrofit.</li>
    <li><code>NewsModule</code>: provides the <code>NewsAPI</code> and <code>RedditApi</code> instances.</li>
</ul>
<p>Also you need to provide is the “<code>NewsManager</code>” but it is not listed in any Module class, this is because you can annotate a constructor of a class that you created with the “<code>@Inject</code>” annotation and Dagger by default will create a <code>Factory</code> and make this class available to be provided like any other “<code>@Provide</code>” in the module classes. Kotlin also allows you to add annotations inlined with the constructor in this way:</p>
<pre><code>@Singleton
class NewsManager @Inject constructor(private val api: NewsAPI) {
    ...
}</code></pre>
<p><b>@Injects</b></p>
<p>Dependencies are requested in 2 places:</p>
<ul>
    <li><code>NewsManager</code>: as you saw previously in the constructor.</li>
    <li><code>NewsFragment</code>: you need here the <code>NewsManager</code>:</li>
</ul>
<pre><code>@Inject lateinit var newsManager: NewsManager</code></pre>
<blockquote>Remember that ‘<code>lateinit</code>’ allows you to define a non-nullable property and set the value later.</blockquote>
<p><b>@Component</b></p>
<p>A component called “<code>NewsComponent</code>” was created which will be the bridge between the modules and injections:</p>
<pre><code>@Singleton
@Component(modules = arrayOf(
        AppModule::class,
        NewsModule::class,
        NetworkModule::class)
)
interface NewsComponent {
    fun inject(newsFragment: NewsFragment)
}</code></pre>
<p>At least for now you don’t need to expose any other thing than a method to inject dependencies for the <code>NewsFragment</code>. Dagger will implement this method, search for injectable annotations and provides them.</p>
<p><b>Binding Altogether</b></p>
<p>As you know, Dagger will create a new class called <code>DaggerNewsComponent</code> which will have a builder to create an implementation of our <code>NewsComponent</code> interface. You are going to create an instance of this and make it available from the <code>KedditApp</code> class in a static way:</p>
<pre><code>companion object {
    lateinit var newsComponent: NewsComponent
}
newsComponent = DaggerNewsComponent.builder()
        .appModule(AppModule(this))
        //.newsModule(NewsModule()) NOT REQUIRED
        .build()</code></pre>
<blockquote>Modules with empty constructor are implicitly created by Dagger, so in this case you don’t need to do “<code>.newsModule(…)</code>”, the <code>NewsModule</code> will be created inside the builder for you.</blockquote>
<p>You can use this <code>newsComponent</code> in this way from your <code>NewsFragment</code>:</p>
<pre><code>override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    KedditApp.newsComponent.inject(this)
}</code></pre>
<p><b>Task:</b></p>
<p>Provide the necessary annotations int the di package (all of the files), <code>NewsFragment.kt</code> and <code>NewsManager.kt</code></p>
</html>