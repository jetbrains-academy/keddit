<html>
<p><b>Safe ?: Safe!</b></p>
<p>This is one of the great things about Kotlin, everything in Kotlin is not nullable unless you specifically declare it in this way. The way to do this is with the “?” question mark which also suggest you that the value could be there or not.</p>
<p>With that being said, let’s see some examples:</p>
<pre><code>val a : String = null  // don't compile!
var b : Int          // neither as must be initialized or abstract.
val ok : String? = null // OK :)</code></pre>
<p>The compiler will be checking the presence of a possible null object, this will prevent us to make the common mistake of getting a “NullPointerException” or well known as the “Billion-dollar mistake” by Tony Hoare.</p>
<p><b>Safe call</b></p>
<p>To interact with a nullable object is really easy, the “?” question mark will allow you to get the value just in case it exists, otherwise it will ignore it and you are safe to continue running the program:</p>
<pre><code>val context : Context? = null
val res = context?.getResources() // not crash, res will be null</code></pre>
<p><b>Smart cast</b></p>
<p>If you continue playing with nullable objects maybe you end up doing this:</p>
<pre><code>val context : Context? = null
val res = context?.getResources()
val appName = res?.getString(R.string.app_name)
val shortName = appName?.substring(0, 2)</code></pre>
<p>This is awful, but you can do this in a better way with smart cast. Just check if context is null and inside the if block the context will be considered as a non-nullable object:</p>
<pre><code>val context : Context? = null
if (context != null) {
    val res = context.getResources()    // Don't need '?' anymore
    val appName = res.getString(R.string.app_name)
    val shortName = appName.substring(0, 2)
}
val context : Context? = null
context?.let {
    val res = context.getResources()    // Don't need '?' anymore
    val appName = res.getString(R.string.app_name)
    val shortName = appName.substring(0, 2)
}</code></pre>
</html>